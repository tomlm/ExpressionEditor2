@page "/"
@inherits LayoutComponentBase
@implements IDisposable
@inject IJSRuntime JS
@using Blazorise
@using Blazorise.Components
@using Microsoft.Extensions.Logging.Abstractions
@using Microsoft.PowerFx.LanguageServerProtocol.Protocol
@using Newtonsoft.Json
@using NJsonSchema
@using Microsoft.AdaptiveFX;
@using BlazorMonaco
@using Microsoft.PowerCards;
@using Microsoft.PowerCards.Interfaces;
@using Microsoft.PowerCards.Scripting;

<!-- @using BlazorMonaco.Bridge-->
@using Newtonsoft.Json.Linq
<!-- layout -->
<div class="pageGrid">
    <!-- <TextEdit class="grid-expression" Placeholder="Enter expression..." @bind-Text="Expression" Size="Size.Large" /> -->
    <Alert Class="grid-alert" Color="Color.Warning" @bind-Visible="@ShowAlert">
        <AlertMessage>
            Error
        </AlertMessage>
        <AlertMessage>
            @Error
        </AlertMessage>
    </Alert>

    <Text Class="grid-memory-heading">Memory Diff</Text>

    <Text Class="grid-eval-result-heading">Last Statement Result</Text>

    <MonacoEditor @ref="_powerfx" Id="powerfx" ConstructionOptions="PowerFXContructionOptions" CssClass="grid-expression"
                  OnDidChangeModelContent="OnEditorChangeModelContent" />

    <MonacoDiffEditor @ref="_memory" Id="memory" ConstructionOptions="DiffEditorConstructionOptions" CssClass="grid-memory"
                      OnDidInit="OnMemoryDidInit" OnDidChangeModelContentOriginal="OnMemoryChangeModelContentOriginal" />

    <MonacoEditor @ref="_evalResult" Id="evalResult" ConstructionOptions="ResultContructionOptions" CssClass="grid-eval-result" />


</div>


@code {
    private string grid;

    private MonacoEditor _powerfx;
    private MonacoDiffEditor _memory;
    private MonacoEditor _evalResult;
    private DotNetObjectReference<Index> _objectReference;

    private string error;

    public string Error { get { return error; } set { error = value; } }

    private bool ShowAlert { get { return !String.IsNullOrEmpty(this.Error); } set { } }

    private Expression exp;
    private string expression;
    public string Expression
    {
        get
        {
            return expression;
        }
        set
        {
            expression = value;
            exp = null;
            try
            {
                exp = Microsoft.AdaptiveFX.Expression.Parse(value);
                Error = null;
            }
            catch (Exception err)
            {
                Error = err.Message;
            }

            EvaluateExpression().ContinueWith(x => x.IsFaulted);
        }
    }

    protected override void OnInitialized()
    {
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        if (firstRender)
        {
            _objectReference = DotNetObjectReference.Create(this);
            JS.InvokeVoidAsync("PowerFX.registerLanguage", _objectReference);
        }
    }
    async Task EvaluateExpression()
    {
        var data = await _memory.OriginalEditor.GetValue();
        var dataObj = YamlConvert.DeserializeObject(data);

        // format data window
        var dataClean = YamlConvert.SerializeObject(dataObj);
        if (String.Compare(data, dataClean) != 0)
        {
            await _memory.OriginalEditor.SetValue(dataClean);
            await _memory.ModifiedEditor.SetValue(dataClean);
        }

        if (this.exp != null)
        {
            try
            {
                var result = await this.exp.TryEvaluate(dataObj);
                this.Error = null;
                await _evalResult.SetValue(YamlConvert.SerializeObject(result));
                await _memory.ModifiedEditor.SetValue(YamlConvert.SerializeObject(dataObj));
            }
            catch (Exception err)
            {
                this.Error = err.Message;
                await _evalResult.SetValue(" ");
                await _memory.ModifiedEditor.SetValue(dataClean);
            }
        }
        await _memory.Layout();
    }

    private int GetCaretFromPosition(string expression, BlazorMonaco.Position position)
    {
        var lines = expression.Split('\n');
        var caret = position.Column - 1;
        for (int i = 0; i < position.LineNumber - 1; i++)
        {
            caret += lines[i].Length + 1;
        }
        return caret;
    }

    private async Task<AdaptiveFXScriptRunner> CreateScriptRunner()
    {
        var dataYaml = await _memory.OriginalEditor.GetValue();
        var yobj = YamlConvert.DeserializeObject(dataYaml);
        var json = ((JObject)yobj).ToString();
        var schema = JsonSchema.FromSampleJson(json);
        var schema2 = Newtonsoft.Json.Schema.JSchema.Parse(schema.ToJson());
        schema2.Properties.Remove("viewer");
        var powerCard = new PowerCard()
            {
                Variables = schema2.Properties
            };
        var context = new ScriptContext(powerCard);
        return new AdaptiveFXScriptRunner(NullLogger.Instance, context);
    }

    [JSInvokable(nameof(PowerFXCompletionItems))]
    public async Task<object[]> PowerFXCompletionItems(BlazorMonaco.Position position)
    {
        var expression = await _powerfx.GetValue();
        int caret = GetCaretFromPosition(expression, position);
        var scriptRunner = await CreateScriptRunner();
        var completionItems = await scriptRunner.GetCompletionItemsAsync(expression, caret, CancellationToken.None);
        return completionItems.Select(ci => new
        {
            documentation = ci.Documentation,
            detail = ci.Detail,
            kind = ci.Kind,
            label = ci.Label,
            insertText = ci.Label
        }).ToArray();
    }


    [JSInvokable(nameof(PowerFXSignatureHelp))]
    public async Task<SignatureHelp> PowerFXSignatureHelp(BlazorMonaco.Position position)
    {
        var expression = await _powerfx.GetValue();
        int caret = GetCaretFromPosition(expression, position);
        var scriptRunner = await CreateScriptRunner();
        var signatureHelp = await scriptRunner.GetSignatureHelpAsync(expression, caret, CancellationToken.None);
        return signatureHelp;
    }

    [JSInvokable(nameof(OnResize))]
    public async Task OnResize()
    {
        await _memory.Layout();
    }

    private async Task OnMemoryDidInit(MonacoEditorBase editor)
    {
        // Get or create the original model
        var memory = @"
isVip: true
viewer:
  id: '123123123'
  name: John Doe
  aadObjectId: '{123123-123123-123123}'
numbers: [1, 2, 3, 4, 5]
homeAddress: 
  street: 123 electric boogaloo
  city: Funkytown
  state: Florida
  zip: 12345
workAddress:
  street: Main street
  city: Pottersville
  state: Hollywood
  zip: 54321
phoneNumbers:
- type: mobile
  number: 555-123-4567
- type: mobile
  number: 555-123-0987
- type: home
  number: 555-888-9999
- type: work
  number: 555-777-1111
";
        await _memory.SetModel(new DiffEditorModel
            {
                Original = await MonacoEditorBase.CreateModel(memory, "yaml"),
                Modified = await MonacoEditorBase.CreateModel(memory, "yaml")
            });
    }

    private async Task OnMemoryChangeModelContentOriginal(ModelContentChangedEvent evt)
    {
        await EvaluateExpression();
    }

    private async Task OnEditorChangeModelContent(ModelContentChangedEvent eventArgs)
    {
        this.Expression = await _powerfx.GetValue();
    }

    private StandaloneEditorConstructionOptions PowerFXContructionOptions(MonacoEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                Language = "powerfx",
                Theme = "vs-dark",
                Folding = true,
                AutomaticLayout = true,
                Value = ""
            };
    }

    private StandaloneEditorConstructionOptions ResultContructionOptions(MonacoEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                Language = "yaml",
                Theme = "vs-dark",
                Folding = true,
                AutomaticLayout = true,
                Value = " "
            };
    }

    private DiffEditorConstructionOptions DiffEditorConstructionOptions(MonacoDiffEditor editor)
    {
        return new DiffEditorConstructionOptions
            {
                OriginalEditable = true,
                AutoIndent = true,
                FormatOnPaste = true,
            };
    }

    public void Dispose()
    {
        GC.SuppressFinalize(this);
        if (_objectReference != null)
        {
            //Now dispose our object reference so our component can be garbage collected
            _objectReference.Dispose();
        }
    }
}
