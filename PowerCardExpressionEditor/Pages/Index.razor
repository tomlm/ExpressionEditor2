@page "/"
@inherits LayoutComponentBase
@implements IDisposable
@inject IJSRuntime JS
@using Blazorise
@using Blazorise.Components
@using Microsoft.Extensions.Logging.Abstractions
@using Microsoft.PowerFx.LanguageServerProtocol.Protocol
@using Newtonsoft.Json
@using Microsoft.AdaptiveFX;
@using BlazorMonaco
@using Microsoft.PowerCards;
@using Microsoft.PowerCards.Interfaces;
@using Microsoft.PowerCards.Scripting;

<!-- @using BlazorMonaco.Bridge-->
<!-- layout -->
<div class="pageGrid">
    <!-- <TextEdit class="grid-expression" Placeholder="Enter expression..." @bind-Text="Expression" Size="Size.Large" /> -->
    <Alert Class="grid-alert" Color="Color.Warning" @bind-Visible="@ShowAlert">
        <AlertMessage>
            Error
        </AlertMessage>
        <AlertMessage>
            @Error
        </AlertMessage>
    </Alert>

    <Text Class="grid-memory-heading">Memory Diff</Text>

    <Text Class="grid-eval-result-heading">Last Statement Result</Text>

    <MonacoEditor @ref="_powerfx" Id="powerfx" ConstructionOptions="PowerFXContructionOptions" CssClass="grid-expression"
                  OnDidChangeModelContent="OnEditorChangeModelContent" />

    <MonacoDiffEditor @ref="_memory" Id="memory" ConstructionOptions="DiffEditorConstructionOptions" CssClass="grid-memory"
                      OnDidInit="OnMemoryDidInit" OnDidChangeModelContentOriginal="OnMemoryChangeModelContentOriginal" />

    <MonacoEditor @ref="_evalResult" Id="evalResult" ConstructionOptions="ResultContructionOptions" CssClass="grid-eval-result" />


</div>


@code {
    private string grid;

    private MonacoEditor _powerfx;
    private MonacoDiffEditor _memory;
    private MonacoEditor _evalResult;
    private DotNetObjectReference<Index> _objectReference;

    private string error;

    public string Error { get { return error; } set { error = value; } }

    private bool ShowAlert { get { return !String.IsNullOrEmpty(this.Error); } set { } }

    private Expression exp;
    private string expression;
    public string Expression
    {
        get
        {
            return expression;
        }
        set
        {
            expression = value;
            exp = null;
            try
            {
                exp = Microsoft.AdaptiveFX.Expression.Parse(value);
                Error = null;
            }
            catch (Exception err)
            {
                Error = err.Message;
            }

            EvaluateExpression().ContinueWith(x => x.IsFaulted);
        }
    }

    protected override void OnInitialized()
    {
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        if (firstRender)
        {
            _objectReference = DotNetObjectReference.Create(this);
            JS.InvokeVoidAsync("PowerFX.registerLanguage", _objectReference);
        }
    }
    async Task EvaluateExpression()
    {
        var data = await _memory.OriginalEditor.GetValue();
        var dataObj = YamlConvert.DeserializeObject(data);

        // format data window
        var dataClean = YamlConvert.SerializeObject(dataObj);
        if (String.Compare(data, dataClean) != 0)
        {
            await _memory.OriginalEditor.SetValue(dataClean);
            await _memory.ModifiedEditor.SetValue(dataClean);
        }

        if (this.exp != null)
        {
            try
            {
                var result = await this.exp.TryEvaluate(dataObj);
                this.Error = null;
                await _evalResult.SetValue(YamlConvert.SerializeObject(result));
                await _memory.ModifiedEditor.SetValue(YamlConvert.SerializeObject(dataObj));
            }
            catch (Exception err)
            {
                this.Error = err.Message;
                await _evalResult.SetValue(" ");
                await _memory.ModifiedEditor.SetValue(dataClean);
            }
        }
    }

    private int GetCaretFromPosition(string expression, BlazorMonaco.Position position)
    {
        var lines = expression.Split('\n');
        var caret = position.Column - 1;
        for (int i = 0; i < position.LineNumber - 1; i++)
        {
            caret += lines[i].Length + 1;
        }
        return caret;
    }

    private AdaptiveFXScriptRunner CreateScriptRunner()
    {
        var powerCard = new PowerCard();
        var context = new ScriptContext(powerCard);
        return new AdaptiveFXScriptRunner(NullLogger.Instance, context);
    }

    [JSInvokable(nameof(PowerFXCompletionItems))]
    public async Task<CompletionItem[]> PowerFXCompletionItems(BlazorMonaco.Position position)
    {
        var expression = await _powerfx.GetValue();
        int caret = GetCaretFromPosition(expression, position);
        var scriptRunner = CreateScriptRunner();
        var completionItems = await scriptRunner.GetCompletionItemsAsync(expression, caret, CancellationToken.None);
        return completionItems.ToArray();
    }


    [JSInvokable(nameof(PowerFXSignatureHelp))]
    public async Task<SignatureHelp> PowerFXSignatureHelp(BlazorMonaco.Position position)
    {
        var expression = await _powerfx.GetValue();
        int caret = GetCaretFromPosition(expression, position);
        var scriptRunner = CreateScriptRunner();
        var signatureHelp = await scriptRunner.GetSignatureHelpAsync(expression, caret, CancellationToken.None);
        return signatureHelp;
    }

    private async Task OnMemoryDidInit(MonacoEditorBase editor)
    {
        // Get or create the original model
        var memory = YamlConvert.SerializeObject(JsonConvert.DeserializeObject("{\"isVip\":true,\"viewer\":{\"id\":\"123123123\",\"name\":\"John Doe\",\"aadObjectId\":\"{123123-123123-123123}\"},\"numbers\":[1,2,3,4,5],\"addresses\":[{\"street\":\"123 electric boogaloo\",\"city\":\"Funkytown\",\"state\":\"Florida\",\"zip\":12345},{\"street\":\"Main street\",\"city\":\"Pottersville\",\"state\":\"Hollywood\",\"zip\":54321}]}"));
        await _memory.SetModel(new DiffEditorModel
            {
                Original = await MonacoEditorBase.CreateModel(memory, "yaml"),
                Modified = await MonacoEditorBase.CreateModel(memory, "yaml")
            });
    }

    private async Task OnMemoryChangeModelContentOriginal(ModelContentChangedEvent evt)
    {
        await EvaluateExpression();
    }

    private async Task OnEditorChangeModelContent(ModelContentChangedEvent eventArgs)
    {
        this.Expression = await _powerfx.GetValue();
    }

    private StandaloneEditorConstructionOptions PowerFXContructionOptions(MonacoEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                Language = "powerfx",
                Theme = "vs-dark",
                Folding = true,
                AutomaticLayout = true,
                Value = ""
            };
    }

    private StandaloneEditorConstructionOptions ResultContructionOptions(MonacoEditor editor)
    {
        return new StandaloneEditorConstructionOptions
            {
                Language = "yaml",
                Theme = "vs-dark",
                Folding = true,
                AutomaticLayout = true,
                Value = " "
            };
    }

    private DiffEditorConstructionOptions DiffEditorConstructionOptions(MonacoDiffEditor editor)
    {
        return new DiffEditorConstructionOptions
            {
                OriginalEditable = true,
                AutoIndent = true,
                FormatOnPaste = true,
            };
    }

    public void Dispose()
    {
        GC.SuppressFinalize(this);
        if (_objectReference != null)
        {
            //Now dispose our object reference so our component can be garbage collected
            _objectReference.Dispose();
        }
    }
}
